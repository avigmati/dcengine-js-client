{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///dcengine.js","webpack:///webpack/bootstrap c5239a65fc67eb482f81","webpack:///./src/index.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","ServerException","error","action_obj","ClientException","RequestException","error_data","get_consumer","consumer_name","registered_consumers","consumer","target","push","constructor","call_action","obj","path","path_str","data","func","part","length","splice","indexOf","Promise","resolve","reject","executeWaitForCriteria","f","criteria","interval","setTimeout","dce","action","dcengine","__proto__","split","then","result","initialized","debug","DCE_DEBUG","socket_url","DCE_SOCKET_URL","Core","[object Object]","url","socket","WebSocket","socketQueueId","socketQueue","consumer_handler","init_handler","onmessage","event","response","JSON","parse","e","execFunc","msg_type","status","actions","version","onopen","console","log","onclose","message","callback","waitForConnection","cmd_id","send","stringify","Array","isArray","callbacks","send_func","readyState","that","action_name","action_type","send_rpc","send_consumer","handler","DCEngine","init","bind","base_consumer","core","set_consumer_handler","set_init_handler","base","names","lastName","arguments","pop","found","get_action","log_actions","map","method","args","type","create_action_proto","toUpperCase","x","consumers"],"mappings":"CAAA,SAAAA,EAAAC,GACA,iBAAAC,SAAA,iBAAAC,OACAA,OAAAD,QAAAD,IACA,mBAAAG,eAAAC,IACAD,UAAAH,GACA,iBAAAC,QACAA,QAAA,SAAAD,IAEAD,EAAA,SAAAC,KACCK,KAAA,WACD,OCAgB,SAAUC,GCN1B,SAAAC,EAAAC,GAGA,GAAAC,EAAAD,GACA,OAAAC,EAAAD,GAAAP,QAGA,IAAAC,EAAAO,EAAAD,IACAE,EAAAF,EACAG,GAAA,EACAV,YAUA,OANAK,EAAAE,GAAAI,KAAAV,EAAAD,QAAAC,IAAAD,QAAAM,GAGAL,EAAAS,GAAA,EAGAT,EAAAD,QAvBA,IAAAQ,KA+DA,OAnCAF,EAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAG,EAAA,SAAAK,GAA2C,OAAAA,GAG3CR,EAAAS,EAAA,SAAAf,EAAAgB,EAAAC,GACAX,EAAAY,EAAAlB,EAAAgB,IACAG,OAAAC,eAAApB,EAAAgB,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAX,EAAAkB,EAAA,SAAAvB,GACA,IAAAgB,EAAAhB,KAAAwB,WACA,WAA2B,OAAAxB,EAAA,SAC3B,WAAiC,OAAAA,GAEjC,OADAK,EAAAS,EAAAE,EAAA,IAAAA,GACAA,GAIAX,EAAAY,EAAA,SAAAQ,EAAAC,GAAsD,OAAAR,OAAAS,UAAAC,eAAAlB,KAAAe,EAAAC,IAGtDrB,EAAAwB,EAAA,GAGAxB,IAAAyB,EAAA,KDgBM,SAAU9B,EAAQ+B,EAAqB1B,GAE7C,aE3EA,SAAA2B,EAAAC,EAAAC,GACA/B,KAAA8B,MAAA,0BAAAA,EACA9B,KAAA+B,aAIA,SAAAC,EAAAF,GACA9B,KAAA8B,MAAA,0BAAAA,EAIA,SAAAG,EAAAH,EAAAI,GACAlC,KAAA8B,MAAA,2BAAAA,EACA9B,KAAAkC,aAiQA,SAAAC,EAAAC,GAIA,QAAA3B,KAAA4B,EACA,GAAA5B,EAAAG,OAAAwB,EACA,OAAA3B,EAAA6B,SAKA,SAAAA,EAAAC,GAIAF,EAAAG,MACA5B,KAAA2B,EAAAf,UAAAiB,YAAA7B,KACA0B,SAAAC,EAAAf,UAAAc,WAIA,SAAAI,EAAAC,EAAAC,EAAAC,EAAAC,GAIA,IAAAC,EAAAJ,EACA,sBAAAI,EACA,OAAAA,EAAAD,GAEA,QAAAE,KAAAJ,EACA,GAAAD,EAAAlB,eAAAuB,IACAJ,EAAAK,OAEA,OADAL,EAAAM,OAAAN,EAAAO,QAAAH,GAAA,GACAN,EAAAC,EAAAK,GAAAJ,EAAAC,EAAAC,GAKA,WAAAM,QAAA,CAAAC,EAAAC,KACAA,EAAAT,EAAA,uBAIA,SAAAU,EAAAC,EAAAC,EAAAC,GACAD,IACAD,IAEAG,WAAA,WACAJ,EAAAC,EAAAC,EAAAC,IACSA,GAQT,SAAAE,EAAAC,EAAAf,GACA,WAAAM,QAAA,CAAAC,EAAAC,KACAC,EAAA,KACAb,EAAAoB,EAAAC,UAAAF,EAAAG,MAAA,KAAAH,EAAAf,GAAAmB,KAAA,SAAAC,GACAb,EAAAa,IACiB,SAAApC,GACjBwB,EAAAxB,MAGA,IACAqC,EAEA,OFvQApD,OAAOC,eAAeY,EAAqB,cAAgBlB,OAAO,IACjCkB,EAA8B,SAAIU,EAClCV,EAAyB,IAAIgC,EE7D9D,IAAAO,GAAA,EAEA,MAAAC,EAAA,oBAAAC,qBAEA,IAAAC,EACA,uBAAAC,eACA,UAAAvC,EAAA,6BAEAsC,EAAAC,eAGA,IAAAlC,WAGAmC,EACAC,YAAAC,EAAAN,GACApE,KAAAoE,QACApE,KAAA2E,OAAA,IAAAC,UAAAF,GACA1E,KAAA6E,cAAA,EACA7E,KAAA8E,eAEA9E,KAAA+E,iBAAA,KACA/E,KAAAgF,aAAA,KAEAhF,KAAA2E,OAAAM,UAAA,CAAAC,IACA,IAAAC,KACA,IACAA,EAAAC,KAAAC,MAAAH,EAAApC,MACa,MAAAwC,GACb,UAAAtD,EAAA,8BAAAsD,GAMA,YAAAH,EAAA,2BAAAnF,KAAA8E,YAAA,KAAAK,EAAA,SACA,IAAAI,EAAAvF,KAAA8E,YAAA,KAAAK,EAAA,QACAI,EAAAJ,UACAnF,KAAA8E,YAAA,KAAAK,EAAA,aAMA,mBAAAA,EAAAK,UAIA,OACA,aAAAL,EAAAM,OACA,UAAA5D,EAAAsD,EAAArD,MAAAqD,EAAAjD,YAEAlC,KAAAgF,aAAAG,EAAArC,KAAA4C,QAAAP,EAAArC,KAAA6C,SAEA,MAIA,OACA3F,KAAA+E,iBAAAI,MAKAnF,KAAA2E,OAAAiB,OAAA,CAAAV,IACAlF,KAAAoE,OACAyB,QAAAC,IAAA,kBAGA9F,KAAA2E,OAAAoB,QAAA,MACA/F,KAAAoE,OACAyB,QAAAC,IAAA,mBAKArB,SAAAuB,EAAAC,GACAjG,KAAAkG,kBAAA,UAEA,IAAAD,IACAjG,KAAA6E,gBACA7E,KAAA8E,YAAA,KAAA9E,KAAA6E,eAAAoB,EACAD,EAAAG,OAAAnG,KAAA6E,cACA7E,KAAA2E,OAAAyB,KAAAhB,KAAAiB,UAAAL,MAGS,KAGTvB,cAAAuB,GACAhG,KAAAkG,kBAAA,KAEAI,MAAAC,QAAAP,EAAAlD,KAAA0D,WACAR,EAAAQ,UAAAR,EAAAlD,KAAA0D,UAEAR,EAAAQ,aAEAxG,KAAA2E,OAAAyB,KAAAhB,KAAAiB,UAAAL,KAES,KAGTvB,kBAAAgC,EAAA/C,GACA,OAAA1D,KAAA2E,OAAA+B,WACAD,QACS,CACT,IAAAE,EAAA3G,KACA2D,WAAA,WACAgD,EAAAT,kBAAAO,EAAA/C,IACaA,IAIbe,KAAAmC,EAAAC,EAAA/D,GACA,IAAA6D,EAAA3G,KAEA,cAAA6G,EACA,IAAAzD,QAAA,CAAAC,EAAAC,KACAqD,EAAAG,UAA+BjD,OAAA+C,EAAA9D,QAAoCqC,IACnE,UAAAA,EAAAM,OACApC,EAAA8B,EAAArC,MAEAQ,GAAgCxB,MAAAqD,EAAArD,MAAAgB,KAAAqC,EAAAjD,iBAKhC,IAAAkB,QAAA,CAAAC,EAAAC,KACAD,EAAAsD,EAAAI,eAA4ClD,OAAA+C,EAAA9D,YAK5C2B,qBAAAuC,GACAhH,KAAA+E,iBAAAiC,EAEAvC,iBAAAuC,GACAhH,KAAAgF,aAAAgC,SAKAC,EACAxC,YAAAH,EAAAF,GACApE,KAAAoE,QAEApE,KAAAkH,KAAAlH,KAAAkH,KAAAC,KAAAnH,MACAA,KAAAO,KAAAP,KAAAO,KAAA4G,KAAAnH,MACAA,KAAAoH,cAAApH,KAAAoH,cAAAD,KAAAnH,MAEAA,KAAAqH,KAAA,IAAA7C,EAAAF,EAAAF,GACApE,KAAAqH,KAAAC,qBAAAtH,KAAAoH,eACApH,KAAAqH,KAAAE,iBAAAvH,KAAAkH,MAGAzC,2BAAA+C,EAAAC,EAAA/G,GAIA,IAAAgH,EAAA,IAAAC,UAAA1E,QAAAwE,EAAAG,MACA,QAAAvH,KAAAoH,EACAD,IAAAC,EAAApH,IAAAmH,EAAAC,EAAApH,QAGA,OADAqH,IAAAF,IAAAE,GAAAhH,GACA8G,EAGA/C,kBAAA9B,EAAAC,GAIA,IAAAiF,EAAAlF,EACA,sBAAAkF,EACA,OAAAA,EAEA,QAAA7E,KAAAJ,EACA,GAAAD,EAAAlB,eAAAuB,IACAJ,EAAAK,OAEA,OADAL,EAAAM,OAAAN,EAAAO,QAAAH,GAAA,GACAiE,EAAAa,WAAAnF,EAAAK,GAAAJ,GAOA6B,KAAAiB,EAAAC,GAIA,MAAAoC,EAAArC,EAAAsC,IAAAC,IAEA,IAAAtB,EAAA3G,KACA,IAAAwD,EAAA,YAAA0E,GAAuC,OAAAvB,EAAApG,KAAA0H,EAAArH,QAAAsH,IACvC1E,EAAAhC,UAAA,UAAAyG,EAAArH,KACA4C,EAAAhC,UAAA,UAAAyG,EAAAE,KAGAlB,EAAAmB,oBAAAnB,EAAAzF,UAAAyG,EAAArH,KAAAoD,MAAA,KAAAR,GAGA,UAAAyE,EAAAE,KAAAE,cAAA,KAAAJ,EAAArH,OAEAuD,GAAA,EACAnE,KAAAoE,OACAyB,QAAAC,IAAA,aAAAH,EAAA,8BAAAoC,GAIAtD,KAAAZ,KAAAqE,GAMA,IAAApF,KACA,QAAAwF,KAAAJ,EACAI,IAAAvH,OAAAuH,IAAA,mBAAAA,IACAxF,EAAAwF,GAKA,MAAA9E,EAAAyD,EAAAa,WAAA9H,KAAA+D,UAAAF,EAAAG,MAAA,MAGA,OAAAhE,KAAAqH,KAAA9G,KAAAiD,EAAAhC,UAAA,UAAAgC,EAAAhC,UAAA,UAAAsB,GAGA2B,cAAAuB,GAIA,OAAAM,MAAAC,QAAAP,EAAAuC,YAAAvC,EAAAuC,UAAAtF,OAAA,GACA,OACA,QAAAxC,KAAAuF,EAAAuC,UAAA,CAEA,IAAAjG,EAAAH,EAAA1B,QACA,IAAA6B,GACAA,EAAA0D,EAAAlD,KAAAkD,EAAAlE,MAAAkE,EAAA9D,YAGA,MACA,OACA,aAAA8D,EAAAP,OACA,UAAAxD,EAAA+D,EAAAlE,MAAAkE,EAAA9D,YAEA2D,QAAAC,IAAA,0BAAAE,KA4DA,MAAAlC,EAAA,IAAAmD,EAAA3C,EAAAF","file":"dcengine.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"dcengine\"] = factory();\n\telse\n\t\troot[\"dcengine\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"dcengine\"] = factory();\n\telse\n\t\troot[\"dcengine\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony export (immutable) */ __webpack_exports__[\"consumer\"] = consumer;\n/* harmony export (immutable) */ __webpack_exports__[\"dce\"] = dce;\n\n\n/**\n * django channels engine\n * @author avigmati@gmail.com\n */\n\nfunction ServerException(error, action_obj) {\n    this.error = 'DCEngine server error: '+error;\n    this.action_obj = action_obj;\n}\n\n\nfunction ClientException(error) {\n    this.error = 'DCEngine client error: '+error;\n}\n\n\nfunction RequestException(error, error_data) {\n    this.error = 'DCEngine request error: '+error;\n    this.error_data = error_data;\n}\n\n\nlet initialized = false;\n\nconst debug = (typeof DCE_DEBUG !== 'undefined') ? DCE_DEBUG : false;\n\nlet socket_url;\nif (typeof DCE_SOCKET_URL === 'undefined') {\n    throw new ClientException('DCE_SOCKET_URL undefined.')\n} else {\n    socket_url = DCE_SOCKET_URL;\n}\n\nlet registered_consumers = [];\n\n\nclass Core {\n    constructor(url, debug) {\n        this.debug = debug;\n        this.socket = new WebSocket(url);\n        this.socketQueueId = 0;\n        this.socketQueue = {};\n\n        this.consumer_handler = null;\n        this.init_handler = null;\n\n        this.socket.onmessage = (event) => {\n            let response = {};\n            try {\n                response = JSON.parse(event.data);\n            } catch(e) {\n                throw new ClientException('response json parse error: ' + e);\n            }\n\n            /*\n             * rpc responses\n             * */\n            if (typeof(response['cmd_id']) !== 'undefined' && typeof(this.socketQueue['i_'+response['cmd_id']]) === 'function') {\n                let execFunc = this.socketQueue['i_'+response['cmd_id']];\n                execFunc(response);\n                delete this.socketQueue['i_'+response['cmd_id']];\n            }\n            /*\n             * non rpc responses\n             * */\n            else {\n                switch (response.msg_type === 'service') {\n                    /*\n                     * service messages\n                     * */\n                    case true:\n                        if (response.status === 'error') {\n                            throw new ServerException(response.error, response.error_data);\n                        } else {\n                            this.init_handler(response.data.actions, response.data.version);\n                        }\n                        break;\n                    /*\n                     * user messages\n                     * */\n                    case false:\n                        this.consumer_handler(response);\n                        break;\n                }\n            }\n        };\n        this.socket.onopen = (event) => {\n            if (this.debug) {\n                console.log('Socket open.');\n            }\n        };\n        this.socket.onclose = () => {\n            if (this.debug) {\n                console.log('Socket close.');\n            }\n        }\n    }\n\n    send_rpc(message, callback) {\n        this.waitForConnection(() => {\n\n            if (typeof callback !== 'undefined') {\n                this.socketQueueId++;\n                this.socketQueue['i_'+this.socketQueueId] = callback;\n                message.cmd_id = this.socketQueueId;\n                this.socket.send(JSON.stringify(message));\n            }\n\n        }, 1000);\n    };\n\n    send_consumer(message) {\n        this.waitForConnection(() => {\n\n            if (Array.isArray(message.data.callbacks)) {\n                message.callbacks = message.data.callbacks;\n            } else {\n                message.callbacks = [];\n            }\n            this.socket.send(JSON.stringify(message));\n\n        }, 1000);\n    };\n\n    waitForConnection(send_func, interval) {\n        if (this.socket.readyState === 1) {\n            send_func();\n        } else {\n            let that = this;\n            setTimeout(function () {\n                that.waitForConnection(send_func, interval);\n            }, interval);\n        }\n    };\n\n    call(action_name, action_type, data) {\n        let that = this;\n\n        if (action_type === 'rpc') {\n            return new Promise((resolve, reject) => {\n                that.send_rpc({'action': action_name, 'data': data}, (response) => {\n                    if (response.status !== 'error') {\n                        resolve(response.data)\n                    } else {\n                        reject({error: response.error, data: response.error_data})\n                    }\n                });\n            });\n        } else {\n            return new Promise((resolve, reject) => {\n                resolve(that.send_consumer({'action': action_name, 'data': data}));\n            });\n        }\n    }\n\n    set_consumer_handler(handler) {\n        this.consumer_handler = handler;\n    }\n    set_init_handler(handler) {\n        this.init_handler = handler;\n    }\n}\n\n\nclass DCEngine {\n    constructor(socket_url, debug) {\n        this.debug = debug;\n\n        this.init = this.init.bind(this);\n        this.call = this.call.bind(this);\n        this.base_consumer = this.base_consumer.bind(this);\n\n        this.core = new Core(socket_url, debug);\n        this.core.set_consumer_handler(this.base_consumer);\n        this.core.set_init_handler(this.init);\n    }\n\n    static create_action_proto(base, names, value) {\n        /*\n         Creates nested prototype path for action function\n         */\n        let lastName = arguments.length === 3 ? names.pop() : false;\n        for(let i in names) {\n            base = base[ names[i] ] = base[ names[i] ] || {};\n        }\n        if( lastName ) base = base[ lastName ] = value;\n        return base;\n    };\n\n    static get_action(obj, path) {\n        /*\n         Return action func by provided path\n         */\n        let found = obj;\n        if (typeof found === \"function\") {\n            return found\n        } else {\n            for (let part of path) {\n                if (obj.hasOwnProperty(part)) {\n                    if (path.length) {\n                        path.splice(path.indexOf(part), 1);\n                        return DCEngine.get_action(obj[part], path)\n                    }\n                }\n            }\n        }\n    }\n\n    init(actions, version){\n        /*\n         Initialize actions\n         */\n        const log_actions = actions.map(method => {\n            // create action func\n            let that = this;\n            let f = function(...args) {return that.call(method.name, ...args)};\n            f.prototype['_dce_name'] = method.name;\n            f.prototype['_dce_type'] = method.type;\n\n            // create action func prototype\n            DCEngine.create_action_proto(DCEngine.prototype, method.name.split('.'), f);\n\n            // return log entry\n            return '['+method.type.toUpperCase()+'] '+method.name\n        });\n        initialized = true;\n        if (this.debug) {\n            console.log('DCEngine v'+version+' initialized with actions: ', log_actions);\n        }\n    }\n\n    call(action, ...args){\n        /*\n         Call wrapper on core.call function, prepares data, parameters for call\n         */\n\n        // prepare data\n        let data = {};\n        for (let x of args) {\n            if ((x === Object(x)) && !(typeof x === 'function')) {\n                data = x;\n            }\n        }\n\n        // get action func\n        const f = DCEngine.get_action(this.__proto__, action.split('.'));\n\n        // call action\n        return this.core.call(f.prototype['_dce_name'], f.prototype['_dce_type'], data);\n    };\n\n    base_consumer(message){\n        /*\n         Routes income messages to consumers\n         */\n        switch (Array.isArray(message.consumers) && message.consumers.length > 0) {\n            case true:\n                for (let c of message.consumers) {\n                    // let consumer = this.get_consumer(c);\n                    let consumer = get_consumer(c);\n                    if (typeof consumer !== 'undefined') {\n                        consumer(message.data, message.error, message.error_data)\n                    }\n                }\n                break;\n            case false:\n                if (message.status === 'error') {\n                    throw new RequestException(message.error, message.error_data);\n                } else {\n                    console.log('DCEngine.base_consumer:', message);\n                }\n        }\n    }\n}\n\nfunction get_consumer(consumer_name) {\n    /*\n     Returns consumer class method by consumer class name\n     */\n    for (let c of registered_consumers) {\n        if (c.name === consumer_name) {\n            return c.consumer;\n        }\n    }\n}\n\nfunction consumer(target) {\n    /*\n     Decorator for consumer class\n     */\n    registered_consumers.push({\n        'name': target.prototype.constructor.name,\n        'consumer': target.prototype.consumer\n    });\n}\n\nfunction call_action(obj, path, path_str, data){\n    /*\n     Run action func by provided path\n     */\n    let func = obj;\n    if (typeof func === \"function\") {\n        return func(data)\n    } else {\n        for (let part of path) {\n            if (obj.hasOwnProperty(part)) {\n                if (path.length) {\n                    path.splice(path.indexOf(part), 1);\n                    return call_action(obj[part], path, path_str, data)\n                }\n            }\n        }\n    }\n    return new Promise((resolve, reject) => {\n        reject(path_str + ' not implemented.');\n    });\n}\n\nfunction executeWaitForCriteria(f, criteria, interval) {\n    if (criteria()) {\n        f();\n    } else {\n        setTimeout(function () {\n            executeWaitForCriteria(f, criteria, interval);\n        }, interval);\n    }\n}\n\n\nconst dcengine = new DCEngine(socket_url, debug);\n\n\nfunction dce(action, data) {\n    return new Promise((resolve, reject) => {\n        executeWaitForCriteria(() => {\n                call_action(dcengine.__proto__, action.split('.'), action, data).then(function(result) {\n                    resolve(result);\n                }, function(error) {\n                    reject(error);\n                });\n            },\n            () => {\n                return initialized\n            },\n            500);\n    });\n}\n\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// dcengine.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap c5239a65fc67eb482f81","'use strict';\n\n/**\n * django channels engine\n * @author avigmati@gmail.com\n */\n\nfunction ServerException(error, action_obj) {\n    this.error = 'DCEngine server error: '+error;\n    this.action_obj = action_obj;\n}\n\n\nfunction ClientException(error) {\n    this.error = 'DCEngine client error: '+error;\n}\n\n\nfunction RequestException(error, error_data) {\n    this.error = 'DCEngine request error: '+error;\n    this.error_data = error_data;\n}\n\n\nlet initialized = false;\n\nconst debug = (typeof DCE_DEBUG !== 'undefined') ? DCE_DEBUG : false;\n\nlet socket_url;\nif (typeof DCE_SOCKET_URL === 'undefined') {\n    throw new ClientException('DCE_SOCKET_URL undefined.')\n} else {\n    socket_url = DCE_SOCKET_URL;\n}\n\nlet registered_consumers = [];\n\n\nclass Core {\n    constructor(url, debug) {\n        this.debug = debug;\n        this.socket = new WebSocket(url);\n        this.socketQueueId = 0;\n        this.socketQueue = {};\n\n        this.consumer_handler = null;\n        this.init_handler = null;\n\n        this.socket.onmessage = (event) => {\n            let response = {};\n            try {\n                response = JSON.parse(event.data);\n            } catch(e) {\n                throw new ClientException('response json parse error: ' + e);\n            }\n\n            /*\n             * rpc responses\n             * */\n            if (typeof(response['cmd_id']) !== 'undefined' && typeof(this.socketQueue['i_'+response['cmd_id']]) === 'function') {\n                let execFunc = this.socketQueue['i_'+response['cmd_id']];\n                execFunc(response);\n                delete this.socketQueue['i_'+response['cmd_id']];\n            }\n            /*\n             * non rpc responses\n             * */\n            else {\n                switch (response.msg_type === 'service') {\n                    /*\n                     * service messages\n                     * */\n                    case true:\n                        if (response.status === 'error') {\n                            throw new ServerException(response.error, response.error_data);\n                        } else {\n                            this.init_handler(response.data.actions, response.data.version);\n                        }\n                        break;\n                    /*\n                     * user messages\n                     * */\n                    case false:\n                        this.consumer_handler(response);\n                        break;\n                }\n            }\n        };\n        this.socket.onopen = (event) => {\n            if (this.debug) {\n                console.log('Socket open.');\n            }\n        };\n        this.socket.onclose = () => {\n            if (this.debug) {\n                console.log('Socket close.');\n            }\n        }\n    }\n\n    send_rpc(message, callback) {\n        this.waitForConnection(() => {\n\n            if (typeof callback !== 'undefined') {\n                this.socketQueueId++;\n                this.socketQueue['i_'+this.socketQueueId] = callback;\n                message.cmd_id = this.socketQueueId;\n                this.socket.send(JSON.stringify(message));\n            }\n\n        }, 1000);\n    };\n\n    send_consumer(message) {\n        this.waitForConnection(() => {\n\n            if (Array.isArray(message.data.callbacks)) {\n                message.callbacks = message.data.callbacks;\n            } else {\n                message.callbacks = [];\n            }\n            this.socket.send(JSON.stringify(message));\n\n        }, 1000);\n    };\n\n    waitForConnection(send_func, interval) {\n        if (this.socket.readyState === 1) {\n            send_func();\n        } else {\n            let that = this;\n            setTimeout(function () {\n                that.waitForConnection(send_func, interval);\n            }, interval);\n        }\n    };\n\n    call(action_name, action_type, data) {\n        let that = this;\n\n        if (action_type === 'rpc') {\n            return new Promise((resolve, reject) => {\n                that.send_rpc({'action': action_name, 'data': data}, (response) => {\n                    if (response.status !== 'error') {\n                        resolve(response.data)\n                    } else {\n                        reject({error: response.error, data: response.error_data})\n                    }\n                });\n            });\n        } else {\n            return new Promise((resolve, reject) => {\n                resolve(that.send_consumer({'action': action_name, 'data': data}));\n            });\n        }\n    }\n\n    set_consumer_handler(handler) {\n        this.consumer_handler = handler;\n    }\n    set_init_handler(handler) {\n        this.init_handler = handler;\n    }\n}\n\n\nclass DCEngine {\n    constructor(socket_url, debug) {\n        this.debug = debug;\n\n        this.init = this.init.bind(this);\n        this.call = this.call.bind(this);\n        this.base_consumer = this.base_consumer.bind(this);\n\n        this.core = new Core(socket_url, debug);\n        this.core.set_consumer_handler(this.base_consumer);\n        this.core.set_init_handler(this.init);\n    }\n\n    static create_action_proto(base, names, value) {\n        /*\n         Creates nested prototype path for action function\n         */\n        let lastName = arguments.length === 3 ? names.pop() : false;\n        for(let i in names) {\n            base = base[ names[i] ] = base[ names[i] ] || {};\n        }\n        if( lastName ) base = base[ lastName ] = value;\n        return base;\n    };\n\n    static get_action(obj, path) {\n        /*\n         Return action func by provided path\n         */\n        let found = obj;\n        if (typeof found === \"function\") {\n            return found\n        } else {\n            for (let part of path) {\n                if (obj.hasOwnProperty(part)) {\n                    if (path.length) {\n                        path.splice(path.indexOf(part), 1);\n                        return DCEngine.get_action(obj[part], path)\n                    }\n                }\n            }\n        }\n    }\n\n    init(actions, version){\n        /*\n         Initialize actions\n         */\n        const log_actions = actions.map(method => {\n            // create action func\n            let that = this;\n            let f = function(...args) {return that.call(method.name, ...args)};\n            f.prototype['_dce_name'] = method.name;\n            f.prototype['_dce_type'] = method.type;\n\n            // create action func prototype\n            DCEngine.create_action_proto(DCEngine.prototype, method.name.split('.'), f);\n\n            // return log entry\n            return '['+method.type.toUpperCase()+'] '+method.name\n        });\n        initialized = true;\n        if (this.debug) {\n            console.log('DCEngine v'+version+' initialized with actions: ', log_actions);\n        }\n    }\n\n    call(action, ...args){\n        /*\n         Call wrapper on core.call function, prepares data, parameters for call\n         */\n\n        // prepare data\n        let data = {};\n        for (let x of args) {\n            if ((x === Object(x)) && !(typeof x === 'function')) {\n                data = x;\n            }\n        }\n\n        // get action func\n        const f = DCEngine.get_action(this.__proto__, action.split('.'));\n\n        // call action\n        return this.core.call(f.prototype['_dce_name'], f.prototype['_dce_type'], data);\n    };\n\n    base_consumer(message){\n        /*\n         Routes income messages to consumers\n         */\n        switch (Array.isArray(message.consumers) && message.consumers.length > 0) {\n            case true:\n                for (let c of message.consumers) {\n                    // let consumer = this.get_consumer(c);\n                    let consumer = get_consumer(c);\n                    if (typeof consumer !== 'undefined') {\n                        consumer(message.data, message.error, message.error_data)\n                    }\n                }\n                break;\n            case false:\n                if (message.status === 'error') {\n                    throw new RequestException(message.error, message.error_data);\n                } else {\n                    console.log('DCEngine.base_consumer:', message);\n                }\n        }\n    }\n}\n\nfunction get_consumer(consumer_name) {\n    /*\n     Returns consumer class method by consumer class name\n     */\n    for (let c of registered_consumers) {\n        if (c.name === consumer_name) {\n            return c.consumer;\n        }\n    }\n}\n\nexport function consumer(target) {\n    /*\n     Decorator for consumer class\n     */\n    registered_consumers.push({\n        'name': target.prototype.constructor.name,\n        'consumer': target.prototype.consumer\n    });\n}\n\nfunction call_action(obj, path, path_str, data){\n    /*\n     Run action func by provided path\n     */\n    let func = obj;\n    if (typeof func === \"function\") {\n        return func(data)\n    } else {\n        for (let part of path) {\n            if (obj.hasOwnProperty(part)) {\n                if (path.length) {\n                    path.splice(path.indexOf(part), 1);\n                    return call_action(obj[part], path, path_str, data)\n                }\n            }\n        }\n    }\n    return new Promise((resolve, reject) => {\n        reject(path_str + ' not implemented.');\n    });\n}\n\nfunction executeWaitForCriteria(f, criteria, interval) {\n    if (criteria()) {\n        f();\n    } else {\n        setTimeout(function () {\n            executeWaitForCriteria(f, criteria, interval);\n        }, interval);\n    }\n}\n\n\nconst dcengine = new DCEngine(socket_url, debug);\n\n\nexport function dce(action, data) {\n    return new Promise((resolve, reject) => {\n        executeWaitForCriteria(() => {\n                call_action(dcengine.__proto__, action.split('.'), action, data).then(function(result) {\n                    resolve(result);\n                }, function(error) {\n                    reject(error);\n                });\n            },\n            () => {\n                return initialized\n            },\n            500);\n    });\n}\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.js\n// module id = 0\n// module chunks = 0"],"sourceRoot":""}